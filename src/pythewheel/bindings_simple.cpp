// Simplified Python bindings for theWheel using pybind11
// This provides basic access to core theWheelModel classes for testing
// Note: Some methods generated by macros are not yet exposed

// Define these before any headers
#define _AFXDLL
#define NOMINMAX

// Include MFC/Windows headers BEFORE pybind11 to avoid conflicts
#include <afx.h>
#include <afxwin.h>

// Undefine problematic macros that conflict with Python
#ifdef _DEBUG
#undef _DEBUG
#include <pybind11/pybind11.h>
#include <pybind11/stl.h>
#include <pybind11/operators.h>
#define _DEBUG
#else
#include <pybind11/pybind11.h>
#include <pybind11/stl.h>
#include <pybind11/operators.h>
#endif

// Include utility macros first
#include "UtilMacros.h"

// Now include theWheel headers
#include "Node.h"
#include "Space.h"
#include "NodeLink.h"
#include "VectorD.h"

namespace py = pybind11;

// Minimal MFC app state for Python module
class CPythonModuleApp : public CWinApp
{
public:
    CPythonModuleApp() {}
    virtual BOOL InitInstance() { return TRUE; }
};

// Static instance to initialize MFC
static CPythonModuleApp theApp;

// Helper to convert CString to std::string
std::string CStringToStdString(const CString& cstr) {
    return std::string(CT2A(cstr));
}

// Helper to convert std::string to CString
CString StdStringToCString(const std::string& str) {
    return CString(str.c_str());
}

PYBIND11_MODULE(pythewheel, m) {
    m.doc() = "Python bindings for theWheel semantic visualization system (simplified version)";

    // Bind CVectorD<3> (3D position vector)
    py::class_<CVectorD<3>>(m, "Vector3D")
        .def(py::init<>())
        .def(py::init<REAL, REAL, REAL>())
        .def("__getitem__", [](const CVectorD<3>& v, int i) -> REAL {
            if (i < 0 || i >= 3) throw py::index_error();
            return v[i];
        })
        .def("__setitem__", [](CVectorD<3>& v, int i, REAL value) {
            if (i < 0 || i >= 3) throw py::index_error();
            v[i] = value;
        })
        .def("get_length", &CVectorD<3>::GetLength)
        .def("normalize", &CVectorD<3>::Normalize)
        .def(py::self + py::self)
        .def(py::self - py::self)
        .def(py::self * REAL())
        .def(REAL() * py::self)
        .def("__repr__", [](const CVectorD<3>& v) {
            return "Vector3D(" + std::to_string(v[0]) + ", " +
                   std::to_string(v[1]) + ", " + std::to_string(v[2]) + ")";
        });

    // Bind CNode (simplified - core methods only)
    py::class_<CNode>(m, "Node")
        .def(py::init<>())
        .def(py::init<CSpace*>(), py::arg("space") = nullptr)
        .def(py::init([](CSpace* space, const std::string& name, const std::string& desc) {
            return new CNode(space, StdStringToCString(name), StdStringToCString(desc));
        }), py::arg("space") = nullptr, py::arg("name") = "", py::arg("description") = "")
        // Basic attributes with CString conversion
        .def("get_name", [](CNode* node) {
            return CStringToStdString(node->GetName());
        })
        .def("set_name", [](CNode* node, const std::string& name) {
            node->SetName(StdStringToCString(name));
        })
        .def("get_description", [](CNode* node) {
            return CStringToStdString(node->GetDescription());
        })
        .def("set_description", [](CNode* node, const std::string& desc) {
            node->SetDescription(StdStringToCString(desc));
        })
        // Links
        .def("get_link_count", &CNode::GetLinkCount)
        .def("get_link_weight", &CNode::GetLinkWeight)
        .def("link_to", &CNode::LinkTo,
             py::arg("to_node"),
             py::arg("weight"),
             py::arg("reciprocal") = true)
        .def("unlink", &CNode::Unlink,
             py::arg("node"),
             py::arg("reciprocal") = true)
        // Activation
        .def("get_activation", &CNode::GetActivation)
        .def("set_activation", &CNode::SetActivation)
        .def("get_primary_activation", &CNode::GetPrimaryActivation)
        .def("get_secondary_activation", &CNode::GetSecondaryActivation)
        // Position (using lambda to handle const reference return)
        .def("get_position", [](CNode* node) -> const CVectorD<3>& {
            return node->GetPosition();
        }, py::return_value_policy::reference)
        .def("set_position", [](CNode* node, const CVectorD<3>& pos) {
            node->SetPosition(pos);
        });

    // Bind CSpace (simplified - core methods only)
    py::class_<CSpace>(m, "Space")
        .def(py::init<>())
        // Node management
        .def("get_node_count", &CSpace::GetNodeCount)
        .def("add_node", &CSpace::AddNode,
             py::arg("new_node"),
             py::arg("parent_node") = nullptr)
        .def("remove_node", &CSpace::RemoveNode)
        // Activation
        .def("activate_node", &CSpace::ActivateNode)
        .def("normalize_nodes", &CSpace::NormalizeNodes, py::arg("sum") = 1.0)
        .def("sort_nodes", &CSpace::SortNodes)
        .def("get_total_activation", &CSpace::GetTotalActivation, py::arg("compute") = false);
}
